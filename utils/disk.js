import {execa} from 'execa';
import fs from 'node:fs/promises';
import fsPath from 'node:path';
import {platform} from 'node:os';
import readable from '@momsfriendlydevco/readable';

const osPlatform = platform();


/**
* Perform various utility checks on a path/mount-point
*
* @param {Object} [options] Additional options to mutate behaviour
* @param {Boolean} [options.checkPlatform=true] Verify that this Sanity instance is running on a valid platform first
* @param {Number} [options.minFree=10] Minimum percentage of disk space that should be available
* @param {Boolean} [options.writable] Verify that the path should be writable
*/
export default function SanityUtilsDisk(path, options) {
	let settings = {
		checkPlatform: true,
		minFree: 10,
		writable: false,
		...options,
	};

	if (settings.checkPlatform && !['darwin', 'freebsd', 'linux', 'openbsd', 'sunos'].includes(osPlatform))
		throw new Error('Cannot check diskspace on non Unix compatible systems');

	return Promise.all([
		// Check disk space {{{
		settings.minFree > 0 && Promise.resolve()
			.then(()=> execa('df', [path]))
			.then(({stdout: data}) => data
				.split(/\n+/)
				.filter(Boolean)
			)
			.then(data => data.slice(1)[0]) // Remove first line (headers)
			.then(data => data.split(/\s+/)) // Split by whitespace
			.then(data => { // Decipher df output based on OS
				let device, size, used, avail, mounted;

				if (platform == 'darwin') {
					[device, size, used, avail, , , , , mounted] = data;
				} else {
					[device, size, used, avail, , mounted] = data;
				}

				return {device, size, used, avail, mounted};
			})
			.then(data => ({
				size: data.size * 1024,
				used: data.used * 1024,
				avail: data.avail * 1024,
				usePercent: (data.used / data.size) * 100,
				freePercent: 100 - ((data.used / data.size) * 100),
				mounted: data.mounted,
			}))
			.then(data => data.freePercent <= settings.minFree
				? {free: `FAIL: Only ${data.freePercent.toFixed(1)}% disk remaining - ${readable.fileSize(data.used)} / ${readable.fileSize(data.size)} @ ${data.usePercent.toFixed(1)}% used for mount point ${data.mounted}`}
				: {free: `PASS: ${readable.fileSize(data.used)} / ${readable.fileSize(data.size)} @ ${data.freePercent.toFixed(1)}% free for mount point ${data.mounted}`}
			),
		// }}}
		// Check writable {{{
		settings.writable && Promise.resolve()
			.then(()=> fsPath.join(path, '.WRITE_TEST_' + (Math.random() * 1000000) + '.delme'))
			.then(tempPath =>
				fs.writeFile(tempPath, `Write test generated by Sanity on ${(new Date).toISOString()}`)
					.then(()=> fs.unlink(tempPath))
					.then(()=> ({writeable: 'PASS: Mount point is writable'}))
					.catch(e => ({writable: `FAIL: Write test failed - ${e.toString()}`}))
			),
		// }}}
	])
		.then(results => Object.assign({}, ...results))

}
